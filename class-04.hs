{-
  Все задачи в этом задании должны решаться исключительно с помощью свёрток.
  Явная рекурсия не допускается. Если в решении в качестве вспомогательной
  требуется стандартная функция обработки списков (помимо fold*, scan*), она
  также должна реализовываться свёрткой.

  Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
  возвращают True, например:

  f = undefined -- решение 
  f_test1 = f undefined == undefined -- тест 1
  f_test2 = f undefined == undefined -- тест 2
  f_test3 = f undefined == undefined -- тест 3
-}

{-
 1. Простейшие функции обработки списков
  a) Найти сумму чётных элементов списка с целочисленными элементами.
-}
f1a = foldl(\s x -> if even x then s+x else s) 0
f1a_test1 = f1a [1,2,3,4,5,6,0] == 12 -- тест 1
f1a_test2 = f1a [-2,4,6,22,44] == 74 -- тест 2
f1a_test3 = f1a [1,3,5,9] == 0 -- тест 3
{-
  b) Найти сумму и произведение элементов списка вещественных чисел.
-}
f1b = foldl(\(s,p) x -> (s+x, p*x) ) (0, 1)
f1b_test1 = f1b [1,2,3,4] == (10, 24) -- тест 1
f1b_test2 = f1b [1,2,3,4,5,0] == (15, 0) -- тест 2
f1b_test3 = f1b [-10..(-1)] == (-55, 362880) -- тест 3

{-
  с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length пользоваться нельзя,
     решение должно выполняться в один проход).
-}
f1c [] = 0
f1c xs = s / c
	where (s, c) = foldl(\(s,l) x -> (x+s, l+1)) (0,0) xs
f1c_test1 = f1c [0,1,2,3,4] == 2 -- тест 1
f1c_test2 = f1c [] == 0 -- тест 2
f1c_test3 = f1c [-11..(-1)] == -6 -- тест 3

{-
  d) Найти минимальный элемент списка.
-}
	
f1d xs = foldl1 min xs
f1d_test1 = f1d [1,2,3,4] == 1 -- тест 1
f1d_test2 = f1d [0] == 0 -- тест 2
f1d_test3 = f1d [-11..1] == -11 -- тест 3
{-
  e) Найти наименьший нечётный элемент списка с целочисленными значениями (дополнительным параметром
     функции должно быть значение, возвращаемое по умолчанию( = 2)).
-}
f1e [] = 2
f1e xs = if odd f then f else 2
	where
		f = foldl1(\p x -> if odd x then minodd p x else p) xs
		minodd x y 
			|(odd x) && (even y) = x
			|(odd y) && (even x) = y
			|(odd x) && (odd y) = min x y
			|otherwise = x
			
f1e_test1 = f1e [4,5,76,0,123,9,1,3] == 1
f1e_test2 = f1e [12,0,(-2),8] == 2
f1e_test3 = f1e [9,11,13] == 9

{-
 2. Свёртки, формирующие списки -}
reverse' = foldl (\acc x -> x : acc) [] 
 {-
  a) Сформировать список, содержащий каждый второй элемент исходного.
  -}
  
f2a [] = []
f2a xs = reverse' $ fst $ foldl(\ (acc,n) x  -> if even n then (x:acc, n+1) else (acc,n+1))([],1) xs

f2a_test1 = f2a [4,5,76,0,123,9,1,3] == [5,0,9,3]
--f2a_test2 = f2a [] == [] 
f2a_test3 = f2a [9] == []
  {-
  b) Сформировать список, содержащий первые n элементов исходного.
  -}
f2b  n xs= reverse' $ fst $ foldl(\(acc,k) x  -> if (k<n) then (x:acc, k+1) else (acc,k+1))([],0) xs
{-
  c) Сформировать список, содержащий последние n элементов исходного.
-}
f2c xs n = fst $ foldr(\  x (acc,k) -> if k<n then (x:acc, k+1) else (acc,k+1))([],0) xs
{-
  d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.
  -}

f2d (x:xs) = fst $ foldl(\(acc,x0) y -> if (y > x0) then (acc ++ [y], y) else (acc,y)) ([],x) xs 
 {-
  e) Сформировать список, содержащий все локальные минимумы исходного списка.
  -}

f2e (x:xs) =  res
	where
		(res,_,_) = foldl(\(acc, p2, p1) x -> if (p1>p2) && (p1>x) then (acc ++ [p1],p1,x) else (acc,p1,x))([],x,x) (x:xs)
  {-
  f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. Сформировать
     список слов этой строки.
	 -}
f2f xs = fst $ foldr(\ch (ws, w) -> if (ch == ' ') then (if (w == "") then (ws,w) else ((w:ws),"")) else (ws,ch:w)) ([],"") (' ':xs)
	 
	 {-
  g) Разбить список на непересекающиеся подсписки длиной n элементов.
  -}
  
f2g n xs = res++[ost]
	where
		(res,ost,_) = foldl(\(ws, w, k) x -> if k == n then ((ws ++ [w]), [x], 1) else (ws,w++[x],k+1))([],[],0) xs
  
  {-
  h) Разбить список на подсписки длиной n элементов с перекрывающейся частью в k элементов (k < n).
  -} 

f2h n k xs = res++[ost]
	where
		(res,ost,_,_) = foldl(\(ws, wn, wk, i) x -> if i < n then (if i < (n-k) then (ws,wn++[x],[],i+1) else (ws, wn++[x], wk++[x], i+1)) else ((ws ++ [wn]), wk++[x],  f2c wk (k-(n-k)) ++[x] , k+1))([],[],[],0) xs 
  {-
  k) Сформировать список, содержащий все начальные элементы списка, удовлетворяющие заданному предикату.
-}
f2k p  = foldr(\ x acc -> if p x then x:acc else acc)[]

{-
  l) Повторить каждый элемент списка заданное количество раз.
-}
f2l n = foldr(\x y -> replicate n x ++ y) [] 
{-
  m) Удалить из списка повторяющиеся подряд идущие элементы.
-}
head' xs = f2b 1 xs
f2m (x:xs) =  foldl(\acc z -> if ((head' acc) == z) then acc else z:acc) [x] xs 
{-
  n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов применения
     заданной функции двух аргументов к соответствующим элементам исходных списков.
-}

{-
 3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).
  a) Найти сумму чисел от a до b.
  b) Найти сумму факториалов чисел от a до b (повторные вычисления факториалов не допускаются).
  с) Сформировать список из первых n чисел Фибоначчи.
  d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x (использовать
     n слагаемых).
  e) Проверить, является ли заданное целое число простым.
-}

{-
 4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
   что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
   0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
-}

{-
 5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:
  1) транспонирование матрицы;
  2) сумма двух матриц;
  3) произведение двух матриц.
-}


{-
 6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
  на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
