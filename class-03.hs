import Data.List

import Data.Char

import Data.String

{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка. 
-}

{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный список целых чисел следующим образом:
  a) увеличить все его элементы в два раза;
  b) увеличить все его элементы с четными значениями в два раза;
  с) обнулить все его элементы с нечетными значениями;
  d) удалить из него элементы, большие заданного числа k;
  e) отфильтровать его, оставив в списке только отрицательные числа;
  f) удалить из него все положительные чётные числа.
-}

f11a :: Integral a => [a] -> [a]
f11a = map (*2)
f11b :: Integral a => [a] -> [a]
f11b = map(\x -> if (even x) then (x * 2) else x)
f11c :: Integral a => [a] -> [a]
f11c = map(\x -> if (odd x) then (0) else x)
f11d :: Integral a => a -> [a] -> [a]
f11d k = filter (<= k)
f11e :: Integral a => [a] -> [a]
f11e = filter ( < 0)
f11f :: Integral a => [a] -> [a]
f11f = filter (\x -> (x< 0) || ((x>0) && ( odd x)))

{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
  b) преобразовать декартовы координаты в полярные.
-}
f12a 1 = filter(\(a,b) -> (a > 0) && (b > 0))
f12a 2 = filter(\(a,b) -> (a < 0) && (b > 0))
f12a 3 = filter(\(a,b) -> (a < 0) && (b < 0))
f12a 4 = filter(\(a,b) -> (a > 0) && (b < 0))
f12b = map(\(x,y)->if (x < 0) then (sqrt(x^2+y^2),(atan(y/x)+pi)) else(sqrt(x^2+y^2),(atan(y/x))))
	

{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.
  b) Извлечь из него подсписок слов заданной длины.
  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
-}


f13a :: [String] -> [String]
f13a = map(map(\s -> toUpper s)) 
f13b :: [String] -> Int -> [String]
f13b w n = filter(\s -> length s == n) w
f13c :: [String] -> Char -> [String]
f13c w c = filter(\(s:ss) -> s == c) w
{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.
 b) Список чётных чисел.
 c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
 d) Список символов английского алфавита.
 e) Список строк, представляющих n-значные двоичные числа.
-}

f2a :: [Integer]
f2a = iterate(+1) 0
f2b = iterate(+2) 2
f2c = iterate(\x -> (1+x)/2) 1
f2d = take 26 $ iterate (chr .(+1) . ord) 'a'
f2e 1 = ["1", "0"]
f2e n = iterate(\ss -> (map (\s-> concat[s,"1"]) ss) ++ (map (\s-> concat[s,"0"]) ss))["1"] !! (n-1)
{-
3. Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
  b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
     координаты точек, лежащие в одной координатной четверти.
  c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
     Последний подсписок может содержать менее n элементов.
  d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
     длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
-}
f3a = groupBy(\a b -> isDigit a && isDigit b || (not . isDigit) a && (not . isDigit) b)

f3b = groupBy (\a b -> quarter a == quarter b)
  where
    quarter (x, y)
      | x>=0 && y>=0 = 1
      | x<0 && y>=0 = 2
      | x<0 && y<0 = 3
      | x>=0 && y<0 = 4 

f3c n = takeWhile(\x -> (length x == n)).takeWhile(\x -> (length x > 0)).map(take n).iterate(drop n)
	  
--f3d :: [a] -> Int -> Int -> [[a]]
f3d :: Int -> Int -> [a] -> [[a]]
f3d n m =takeWhile(\x -> (length x > 0)).map(take n).iterate(drop m)
	
-- Должно быть True
test_f3d = f3d 4 2 [1..10] == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

{-
4. Разные задачи.
 a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
    всех упоминающихся в тексте чисел.
 b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
    (например: все чётные от 1 до 106).
 c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
    в строке символов.
 d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
    называется элемент, больший своих соседей.
 e) Дан список. Продублировать все его элементы.
-}

f4a str = length (filter (\(x:xs) -> isDigit x) (f3a str))
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
f4b p a b = sum $ filter p (drop a(take b fibs))
f4c str n = (take n).map(take 1).sortBy(\a b -> compare (length b) (length a)) $ group $ sort str
f4d xs =  map (\(x1:x2:x3:xs) -> x2) $ filter (\(x1:x2:x3:xs) -> x2>x1 && x2>x3) $ filter (\xs -> length xs == 3) $ map (take 3) $ tails xs 
f4e xs = concat $ map (\x -> [x, x]) xs
